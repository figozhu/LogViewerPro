### 完整项目文档：LogViewer Pro (动态日志查看器)



项目版本: 1.0

文档版本: 1.2 (动态解析版)

日期: 2025年11月7日



### 1. 详细需求文档 (DRD)





#### 1.1 项目简介



1.1.1 项目目标

本项目旨在开发一个跨平台的桌面GUI工具，用于快速打开、解析、搜索和过滤大型（GB级别）日志文件。

此工具的核心特性是**支持用户自定义日志格式**。用户通过提供使用“命名捕获组”的正则表达式来定义日志结构，工具将动态地创建数据库表、解析数据，并动态渲染显示列和过滤器。

**1.1.2 目标用户**

- 后端开发人员
- 运维工程师 (SRE / DevOps)
- 质量保障工程师 (QA)

**1.1.3 项目范围 (V1.0)**

| **范围内 (In Scope)**                                       | **范围外 (Out of Scope for V1)**                     |
| ----------------------------------------------------------- | ---------------------------------------------------- |
| ✅ **动态模板管理:** 创建/保存/编辑日志格式模板。            | ❌ **实时日志:** `tail -f` 实时追加日志。             |
| ✅ **动态解析:** 使用模板的 Regex 进行解析。                 | ❌ **日志编辑:** 不支持修改原始日志。                 |
| ✅ **大文件支持:** 通过后台索引支持 >5GB 的文件。            | ❌ **多文件聚合:** 不支持同时打开多个文件并聚合视图。 |
| ✅ **高性能索引:** 使用 SQLite 和 FTS5。                     | ❌ **统计图表:** 不支持日志统计和图表生成。           |
| ✅ **缓存机制:** 已索引文件可瞬时重开。                      |                                                      |
| ✅ **动态UI:** 动态生成表格列和过滤器。                      |                                                      |
| ✅ **跨平台:** Windows, macOS (Intel/Apple Silicon), Linux。 |                                                      |

------



#### 1.2 功能需求 (FR)





##### FR-1: 格式模板管理



| **ID** | **需求描述**                                                 | **优先级** |
| ------ | ------------------------------------------------------------ | ---------- |
| FR-1.1 | 用户必须能创建、保存和管理“日志格式模板”。                   | 高         |
| FR-1.2 | 一个“模板”必须包含以下字段：  1. 模板名称 (e.g., "Game Server Log")  2. **正则表达式 (必须使用命名捕获组)**  3. 指定一个命名组作为**时间戳**字段 (用于排序)  4. 指定一个命名组作为**全文搜索 (FTS)** 字段 (e.g., "message") | 高         |
| FR-1.3 | UI应提供一个简单的界面来测试正则表达式。                     | 中         |



##### FR-2: 文件处理与索引



| **ID** | **需求描述**                                                 | **优先级** |
| ------ | ------------------------------------------------------------ | ---------- |
| FR-2.1 | 用户能通过“文件 -> 打开”或拖拽方式选择一个本地日志文件。     | 高         |
| FR-2.2 | 打开文件时，系统必须提示用户选择一个已保存的模板来解析该文件。 | 高         |
| FR-2.3 | 当打开大文件进行首次索引时，UI必须显示一个清晰的进度条。     | 高         |
| FR-2.4 | **缓存 - 快速重开:** 如果一个文件（使用同一模板）被再次打开，且文件未被修改，则必须跳过索引，瞬时加载。 | 高         |
| FR-2.5 | **缓存 - 失效:** 如果文件被修改（通过检查`mtime`），缓存必须自动失效，并触发重新索引。 | 高         |
| FR-2.6 | 应用应维护一个“最近打开的”文件列表（包含文件路径和所用模板）。 | 中         |



##### FR-3: 日志解析与显示



| **ID** | **需求描述**                                                 | **优先级** |
| ------ | ------------------------------------------------------------ | ---------- |
| FR-3.1 | 系统必须使用所选模板的 Regex 解析文件，提取所有**命名组** (e.g., `(?<level>...)`) 作为字段。 | 高         |
| FR-3.2 | 日志列表的**列**必须根据模板的命名组**动态生成**。           | 高         |
| FR-3.3 | 日志列表必须使用**虚拟滚动**，以支持平滑滚动浏览百万条日志。 | 高         |
| FR-3.4 | 系统应对名为 `level` 的字段进行特殊处理，用不同颜色高亮 (ERROR, WARN)。 | 中         |
| FR-3.5 | 用户点击某一行日志时，应在侧边栏或模态框中显示该行所有字段的详细信息。 | 高         |
| FR-3.6 | 如果详情视图中的字段内容是JSON字符串，应自动将其格式化（Pretty-Print）。 | 中         |



##### FR-4: 搜索与过滤



| **ID** | **需求描述**                                                 | **优先级** |
| ------ | ------------------------------------------------------------ | ---------- |
| FR-4.1 | 提供一个主搜索框，对模板中指定的 `ftsField` 字段执行全文搜索。 | 高         |
| FR-4.2 | 搜索和过滤操作的响应时间应在1秒内（在索引完成后）。          | 高         |
| FR-4.3 | **动态过滤:** 系统应自动检测低基数（low-cardinality）的字段（如 `level`, `method`），并在侧边栏动态生成过滤器（如下拉菜单或复选框）。 | 高         |
| FR-4.4 | 搜索结果在日志列表中应高亮显示。                             | 中         |

------



#### 1.3 非功能需求 (NFR)



| **ID** | **类别** | **需求描述**                                                 |
| ------ | -------- | ------------------------------------------------------------ |
| NFR-1  | 性能     | UI主线程在任何情况下都不能被文件I/O或解析阻塞。              |
| NFR-2  | 跨平台   | 应用程序必须能打包成单一可执行文件，在 Windows, macOS (Intel/AS), 和 Linux 上运行。 |
| NFR-3  | 资源管理 | 索引缓存文件应存储在 `app.getPath('userData')` 目录中。      |
| NFR-4  | 易用性   | 必须提供一个“清除所有索引缓存”的按钮。                       |
| NFR-5  | 健壮性   | 无法被 Regex 匹配的日志行应被（可选地）跳过或标记，而不是使解析失败。 |

------

------



### 2. 技术实现详细设计文档 (TDD)



**版本:** 1.2 (动态模式版)



#### 2.1 核心技术栈



- **应用框架:** **Electron**
- **后端 (Main/Worker):** **Node.js (TypeScript)**
- **前端 (Renderer):** **React (TypeScript)**
- **数据库:** **`better-sqlite3`** (用于在 Worker 线程中进行高性能同步I/O)
- **状态管理:** Zustand (或 Redux / Pinia for Vue)
- **UI 库:** `react-window` (用于虚拟滚动)
- **配置存储:** `electron-store` (用于持久化保存用户创建的模板)



#### 2.2 系统架构



本系统采用 Electron 的 **主进程 + 渲染进程 + 工作线程** 的多进程/线程架构。

1. **主进程 (Main Process / Node.js):**
   - **职责:** 窗口管理、菜单创建、文件对话框、IPC 路由。
   - **角色:** “交通警察”。它不执行任何重度计算，仅负责启动窗口和 Worker 线程，并在它们之间转发消息。
2. **渲染进程 (Renderer Process / Chromium):**
   - **职责:** 负责所有 UI 的渲染 (使用 React)。
   - **角色:** “前台”。显示数据，响应用户输入（点击、滚动、输入），并将任务请求（如“开始索引”、“执行搜索”）通过 IPC 发送给主进程。
3. **工作线程 (Worker Thread / Node.js):**
   - **职责:** **执行所有耗时和CPU密集型任务**，避免阻塞主进程和UI。
   - **角色:** “引擎室”。
     - 索引缓存验证（`mtime` 检查）。
     - 文件流式读取 (`fs.createReadStream`)。
     - 逐行正则表达式解析。
     - SQLite 数据库的写入（批量事务）和查询（FTS5）。

> 架构图:
>
> (Renderer: React UI) <-- IPC --> (Main: Window Mgmt)
>
> (Main) <-- worker_threads channel --> (Worker: Parsing, SQLite)

------



#### 2.3 核心模块设计





##### 2.3.1 模板管理模块



- **存储:** 使用 `electron-store`。

- **数据结构:** 在 `config.json` 中存储一个 `LogTemplate` 对象数组。

  TypeScript

  ```
  interface LogTemplate {
    id: string; // uuid
    name: string; // "Game Server Log"
    regex: string; // "\\[(?<timestamp>.*?)\\] \\[(?<level>.*?)\\]... - (?<message>.*)"
    timestampField: string; // "timestamp"
    ftsField: string; // "message"
  }
  ```

- **UI:** 在 React 中创建一个专门的 `<TemplateManager>` 路由或模态框，用于CRUD操作。



##### 2.3.2 索引引擎模块 (位于 Worker Thread)



这是系统的核心。

**1. 触发与缓存验证:**

- Worker 线程收到 `(filePath, template)` 对象。
- **A. 生成缓存ID:**
  - 缓存ID必须同时反映文件和所用模板。
  - `cacheKey = filePath + template.regex` (使用 Regex 字符串本身，而不是模板名称，以防 Regex 被编辑)。
  - `hash = crypto.createHash('md5').update(cacheKey).digest('hex')`
  - `dbPath = path.join(app.getPath('userData'), 'index_cache', \`${hash}.db`)`
- **B. 缓存检查:**
  - 获取文件当前 `mtime`: `currentMtime = fs.statSync(filePath).mtime.toISOString()`
  - **Case 1 (缓存未命中):** `dbPath` 不存在。-> **执行 [2.3.3] 和 [2.3.4] (全量索引)**。
  - **Case 2 (缓存命中):** `dbPath` 存在。
    1. 打开 `dbPath`。
    2. 查询 `oldMtime`: `SELECT value FROM meta WHERE key = 'source_mtime'`。
    3. **IF (currentMtime === oldMtime):** 缓存有效。发送 `'index:complete' (cacheUsed: true)`，立即结束。
    4. **ELSE (currentMtime !== oldMtime):** 缓存失效。删除旧 `dbPath`，重新执行 **Case 1 (全量索引)**。

**2. 动态数据库 Schema (Dynamic Schema Generation):**

- *此流程仅在缓存未命中时运行。*
- **A. 提取字段名:**
  - 从 `template.regex` 中提取所有命名组：
  - `const namedGroups = template.regex.match(/\(\?<(\w+)>/g).map(g => g.slice(3, -1));`
  - *(结果: `['timestamp', 'level', 'sn', 'message'])*
- **B. 动态构建 `CREATE TABLE`:**
  - 遍历 `namedGroups`，构建 SQL。
  - **策略：** 默认所有字段为 `TEXT`，**除了** `id` (INTEGER) 和 `timestampField` (INTEGER，用于存储 UNIX 时间戳)。
  - `CREATE TABLE logs (id INTEGER PRIMARY KEY, timestamp INTEGER, level TEXT, sn TEXT, message TEXT, ...)`
- **C. 动态构建 `CREATE FTS TABLE`:**
  - `const ftsField = template.ftsField;`
  - `CREATE VIRTUAL TABLE logs_fts USING fts5(${ftsField}, content='logs', content_rowid='id');`
- **D. 创建 `meta` 表:**
  - `CREATE TABLE meta (key TEXT PRIMARY KEY, value TEXT);`

**3. 动态解析与入库 (Dynamic Parsing & Ingestion):**

- **A. 准备:**
  - `const regex = new RegExp(template.regex, 'g');`
  - `const insertStmt = db.prepare('INSERT INTO logs (timestamp, level, ...) VALUES (?, ?, ...)')`
  - **使用事务:** `const insertMany = db.transaction((lines) => { ... });`
- **B. 逐行解析:**
  - 使用 `fs.createReadStream` 和 `readline` 逐行读取。
  - 在循环中：
    1. `const match = regex.exec(line);`
    2. **IF (match):**
       - `const data = match.groups;` // JS Regex 返回一个带 .groups 的对象
       - 将 `data[template.timestampField]` 转换为 UNIX 时间戳 (e.g., `new Date(data[...]).getTime()`)。
       - 将 `data` 对象按 `insertStmt` 要求的顺序转为数组，存入一个临时批次 `batch.push(params)`。
    3. 每 5,000 行（或更多），执行一次 `insertMany(batch)` 并清空 `batch`。
    4. 定期向 Renderer 报告进度 `postMessage({ type: 'progress', ... })`。
- **C. 完成:**
  - `INSERT INTO meta (key, value) VALUES ('source_mtime', currentMtime);`



##### 2.3.3 查询引擎模块 (位于 Worker Thread)



- 接收查询对象：`{ search: 'timeout', filters: { level: 'ERROR', method: 'POST' }, page: 1 }`
- **动态 SQL 构建:**
  - `const ftsField = template.ftsField;`
  - `let whereClauses = [];`
  - `let params = [];`
  - // 全文搜索
  - `if (params.search) { whereClauses.push(`logs_fts.rowid IN (SELECT rowid FROM logs_fts WHERE ${ftsField} MATCH ?)`); params.push(params.search); }`
  - // 动态结构化过滤
  - `for (const [key, value] of Object.entries(params.filters)) { whereClauses.push(\`logs.${key} = ?`); params.push(value); }`
  - `const sql = \`SELECT logs.* FROM logs JOIN logs_fts ON logs.id = logs_fts.rowid WHERE ${whereClauses.join(' AND ')} ORDER BY timestamp DESC LIMIT 100 OFFSET ...`;`
  - 返回 `db.prepare(sql).all(params);`



##### 2.3.4 前端 UI 动态渲染模块 (位于 Renderer Process)



- **状态:** 使用 Zustand 或 Context 存储：
  - `columns: ColumnInfo[]`
  - `rows: LogEntry[]`
  - `filterOptions: Record<string, string[]>`
- **启动流程:**
  1. UI 收到 `'index:complete'` 信号。
  2. UI **立即**向 Worker 请求：`ipcRenderer.invoke('schema:get')`。
  3. Worker 返回 `PRAGMA table_info(logs)` 结果。
  4. UI 更新 `setColumns(...)` 状态。
  5. `<LogTable>` 组件根据 `columns` 状态动态渲染表头和行。
  6. **同时**，UI 请求：`ipcRenderer.invoke('filters:getOptions')`。
  7. Worker 线程对 `columns` 中的 `TEXT` 字段执行 `SELECT DISTINCT ...` 来查找低基数字段。
  8. UI 更新 `setFilterOptions(...)` 状态。
  9. `<Sidebar>` 组件根据 `filterOptions` 动态渲染过滤器。
- **虚拟滚动:**
  - 使用 `react-window` 的 `FixedSizeList` 组件。
  - `itemCount` 设置为日志总数（通过 `SELECT COUNT(*)` 获取）。
  - `Row` 渲染函数负责渲染单行，它会动态遍历 `columns` 状态来渲染每个单元格。

------



#### 2.4 IPC 通信协议 (API)



定义主进程、渲染进程和工作线程之间的通信契约。

| **通道 (Channel)**   | **发送方 -> 接收方**       | **描述**                                              |
| -------------------- | -------------------------- | ----------------------------------------------------- |
| **模板管理**         |                            |                                                       |
| `templates:getAll`   | Renderer -> Main           | (Handle) 请求所有已存的 `LogTemplate`。               |
| `templates:save`     | Renderer -> Main           | (Handle) 保存一个新的或更新的 `LogTemplate`。         |
| `templates:delete`   | Renderer -> Main           | (Handle) 删除一个 `LogTemplate`。                     |
| **文件与索引**       |                            |                                                       |
| `dialog:openFile`    | Renderer -> Main           | (Handle) 触发系统文件打开对话框。                     |
| `index:start`        | Renderer -> Main -> Worker | (Handle) 启动索引。参数: `(filePath, template)`。     |
| `index:progress`     | Worker -> Main -> Renderer | (Send) 报告索引进度。参数: `(progress)`。             |
| `index:complete`     | Worker -> Main -> Renderer | (Send) 索引完成。参数: `(cacheUsed: boolean)`。       |
| **数据与 Schema**    |                            |                                                       |
| `schema:get`         | Renderer -> Main -> Worker | (Handle) **[新]** 获取当前DB的表结构 `ColumnInfo[]`。 |
| `query:run`          | Renderer -> Main -> Worker | (Handle) **[修改]** 执行搜索。参数: `(query)`。       |
| `filters:getOptions` | Renderer -> Main -> Worker | (Handle) **[新]** 获取动态过滤器的选项。              |

